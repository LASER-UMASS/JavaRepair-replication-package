--- ./original/org/apache/commons/math/linear/EigenDecompositionImpl.java	2018-05-10 02:40:32.000000000 -0400
+++ ./variant106/org/apache/commons/math/linear/EigenDecompositionImpl.java	2018-05-10 04:10:36.000000000 -0400
@@ -993,58 +993,72 @@
 
         // step 1: accepting realEigenvalues
         int deflatedEnd = end;
-        for (boolean deflating = true; deflating;) {
-
-            if (start >= deflatedEnd) {
-                // the array has been completely deflated
-                return deflatedEnd;
-            }
-
-            final int k = 4 * deflatedEnd + pingPong - 1;
-
-            if ((start == deflatedEnd - 1) ||
-                ((start != deflatedEnd - 2) &&
-                 ((work[k - 5] <= TOLERANCE_2 * (sigma + work[k - 3])) ||
-                  (work[k - 2 * pingPong - 4] <= TOLERANCE_2 * work[k - 7])))) {
-
-                // one eigenvalue found, deflate array
-                work[4 * deflatedEnd - 4] = sigma + work[4 * deflatedEnd - 4 + pingPong];
-                deflatedEnd -= 1;
-
-            } else if ((start == deflatedEnd - 2) ||
-                (work[k - 9] <= TOLERANCE_2 * sigma) ||
-                (work[k - 2 * pingPong - 8] <= TOLERANCE_2 * work[k - 11])) {
-
-                // two realEigenvalues found, deflate array
-                if (work[k - 3] > work[k - 7]) {
-                    final double tmp = work[k - 3];
-                    work[k - 3] = work[k - 7];
-                    work[k - 7] = tmp;
-                }
-
-                if (work[k - 5] > TOLERANCE_2 * work[k - 3]) {
-                    double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]);
-                    double s = work[k - 3] * (work[k - 5] / t);
-                    if (s <= t) {
-                        s = work[k - 3] * work[k - 5] / (t * (1 + Math.sqrt(1 + s / t)));
-                    } else {
-                        s = work[k - 3] * work[k - 5] / (t + Math.sqrt(t * (t + s)));
-                    }
-                    t = work[k - 7] + (s + work[k - 5]);
-                    work[k - 3] *= work[k - 7] / t;
-                    work[k - 7]  = t;
-                }
-                work[4 * deflatedEnd - 8] = sigma + work[k - 7];
-                work[4 * deflatedEnd - 4] = sigma + work[k - 3];
-                deflatedEnd -= 2;
-            } else {
-
-                // no more realEigenvalues found, we need to iterate
-                deflating = false;
-
-            }
-
-        }
+        {
+			for (boolean deflating = true; deflating;) {
+				if (start >= deflatedEnd) {
+					return deflatedEnd;
+				}
+				final int k = 4 * deflatedEnd + pingPong - 1;
+				if ((start == deflatedEnd - 1)
+						|| ((start != deflatedEnd - 2) && ((work[k - 5] <= TOLERANCE_2 * (sigma + work[k - 3]))
+								|| (work[k - 2 * pingPong - 4] <= TOLERANCE_2 * work[k - 7])))) {
+					work[4 * deflatedEnd - 4] = sigma + work[4 * deflatedEnd - 4 + pingPong];
+					deflatedEnd -= 1;
+				} else if ((start == deflatedEnd - 2) || (work[k - 9] <= TOLERANCE_2 * sigma)
+						|| (work[k - 2 * pingPong - 8] <= TOLERANCE_2 * work[k - 11])) {
+					if (work[k - 3] > work[k - 7]) {
+						final double tmp = work[k - 3];
+						work[k - 3] = work[k - 7];
+						work[k - 7] = tmp;
+					}
+					if (work[k - 5] > TOLERANCE_2 * work[k - 3]) {
+						double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]);
+						double s = work[k - 3] * (work[k - 5] / t);
+						if (s <= t) {
+							s = work[k - 3] * work[k - 5] / (t * (1 + Math.sqrt(1 + s / t)));
+						} else {
+							s = work[k - 3] * work[k - 5] / (t + Math.sqrt(t * (t + s)));
+						}
+						t = work[k - 7] + (s + work[k - 5]);
+						work[k - 3] *= work[k - 7] / t;
+						work[k - 7] = t;
+					}
+					work[4 * deflatedEnd - 8] = sigma + work[k - 7];
+					work[4 * deflatedEnd - 4] = sigma + work[k - 3];
+					deflatedEnd -= 2;
+				} else {
+					deflating = false;
+				}
+			}
+			for (boolean loop = true; loop;) {
+				dqds(start, deflatedEnd);
+				if ((dMin >= 0) && (dMin1 > 0)) {
+					updateSigma(tau);
+					return deflatedEnd;
+				} else if ((dMin < 0.0) && (dMin1 > 0.0)
+						&& (work[4 * deflatedEnd - 5 - pingPong] < TOLERANCE * (sigma + dN1))
+						&& (Math.abs(dN) < TOLERANCE * sigma)) {
+					work[4 * deflatedEnd - 3 - pingPong] = 0.0;
+					dMin = 0.0;
+					updateSigma(tau);
+					return deflatedEnd;
+				} else if (dMin < 0.0) {
+					if (tType < -22) {
+						tau = 0.0;
+					} else if (dMin1 > 0.0) {
+						tau = (tau + dMin) * (1.0 - 2.0 * MathUtils.EPSILON);
+						tType -= 11;
+					} else {
+						tau *= 0.25;
+						tType -= 12;
+					}
+				} else if (Double.isNaN(dMin)) {
+					tau = 0.0;
+				} else {
+					loop = false;
+				}
+			}
+		}
 
         final int l = 4 * deflatedEnd + pingPong - 1;
 
