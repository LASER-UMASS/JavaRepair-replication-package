--- ./original/org/apache/commons/math/linear/EigenDecompositionImpl.java	2018-05-10 02:41:08.000000000 -0400
+++ ./variant39/org/apache/commons/math/linear/EigenDecompositionImpl.java	2018-05-10 05:10:29.000000000 -0400
@@ -1048,20 +1048,19 @@
 
         final int l = 4 * deflatedEnd + pingPong - 1;
 
-        // step 2: flip array if needed
-        if ((dMin <= 0) || (deflatedEnd < end)) {
-            if (flipIfWarranted(deflatedEnd, 1)) {
-                dMin2 = Math.min(dMin2, work[l - 1]);
-                work[l - 1] =
-                    Math.min(work[l - 1],
-                             Math.min(work[3 + pingPong], work[7 + pingPong]));
-                work[l - 2 * pingPong] =
-                    Math.min(work[l - 2 * pingPong],
-                             Math.min(work[6 + pingPong], work[6 + pingPong]));
-                qMax  = Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong]));
-                dMin  = -0.0;
-            }
-        }
+        {
+			if ((dMin <= 0) || (deflatedEnd < end)) {
+				if (flipIfWarranted(deflatedEnd, 1)) {
+					dMin2 = Math.min(dMin2, work[l - 1]);
+					work[l - 1] = Math.min(work[l - 1], Math.min(work[3 + pingPong], work[7 + pingPong]));
+					work[l - 2 * pingPong] = Math.min(work[l - 2 * pingPong],
+							Math.min(work[6 + pingPong], work[6 + pingPong]));
+					qMax = Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong]));
+					dMin = -0.0;
+				}
+			}
+			dN = 0;
+		}
 
         if ((dMin < 0) ||
             (MathUtils.SAFE_MIN * qMax < Math.min(work[l - 1],
