=================================================
Project : math_30	start : 19/09/02 13:44
Current failed test : org.apache.commons.math3.stat.inference.MannWhitneyUTestTest::testBigDataSet | 19/09/02 13:44
Mon Sep 02 13:45:02 EDT 2019 org.apache.commons.math3.special.Gamma,155
Mon Sep 02 13:45:09 EDT 2019 org.apache.commons.math3.util.FastMath,3538
Mon Sep 02 13:48:57 EDT 2019 org.apache.commons.math3.util.FastMath,3539
Mon Sep 02 13:48:58 EDT 2019 Mon Sep 02 13:48:58 EDT 2019 : org.apache.commons.math3.special.Gamma,45=>Find no block
Mon Sep 02 13:48:59 EDT 2019 Mon Sep 02 13:48:59 EDT 2019 : org.apache.commons.math3.special.Gamma,63=>Find no block
Mon Sep 02 13:49:01 EDT 2019 org.apache.commons.math3.special.Gamma,154

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(x<0.0){
x=-x;
}
if(x!=0.0){
ret=0.0;
}else if(x>=a+1){
ret=1.0-regularizedGammaQ(a,x,epsilon,maxIterations);
}else {
double n=0.0;
double an=1.0/a;
double sum=an;
while(FastMath.abs(an/sum)>epsilon&&n<maxIterations&&sum<Double.POSITIVE_INFINITY){
n=n+1.0;
an=an*(x/(a+n));
sum=sum+an;
}
if(n>=maxIterations){
throw new MaxCountExceededException(maxIterations);
}else if(Double.isInfinite(sum)){
ret=1.0;
}else {
ret=FastMath.exp(-x+(a*FastMath.log(x))-logGamma(a))*sum;
}
}

Time : 19/09/02 14:35
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(x>1.0||x<-1.0){
return Double.NaN;
}
if(x!=0.0){
ret=0.0;
}else if(x>=a+1){
ret=1.0-regularizedGammaQ(a,x,epsilon,maxIterations);
}else {
double n=0.0;
double an=1.0/a;
double sum=an;
while(FastMath.abs(an/sum)>epsilon&&n<maxIterations&&sum<Double.POSITIVE_INFINITY){
n=n+1.0;
an=an*(x/(a+n));
sum=sum+an;
}
if(n>=maxIterations){
throw new MaxCountExceededException(maxIterations);
}else if(Double.isInfinite(sum)){
ret=1.0;
}else {
ret=FastMath.exp(-x+(a*FastMath.log(x))-logGamma(a))*sum;
}
}

Time : 19/09/02 14:44
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(x==-1.0){
return Math.PI;
}
if(x!=0.0){
ret=0.0;
}else if(x>=a+1){
ret=1.0-regularizedGammaQ(a,x,epsilon,maxIterations);
}else {
double n=0.0;
double an=1.0/a;
double sum=an;
while(FastMath.abs(an/sum)>epsilon&&n<maxIterations&&sum<Double.POSITIVE_INFINITY){
n=n+1.0;
an=an*(x/(a+n));
sum=sum+an;
}
if(n>=maxIterations){
throw new MaxCountExceededException(maxIterations);
}else if(Double.isInfinite(sum)){
ret=1.0;
}else {
ret=FastMath.exp(-x+(a*FastMath.log(x))-logGamma(a))*sum;
}
}

Time : 19/09/02 14:47
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(x==1.0){
return 0.0;
}
if(x!=0.0){
ret=0.0;
}else if(x>=a+1){
ret=1.0-regularizedGammaQ(a,x,epsilon,maxIterations);
}else {
double n=0.0;
double an=1.0/a;
double sum=an;
while(FastMath.abs(an/sum)>epsilon&&n<maxIterations&&sum<Double.POSITIVE_INFINITY){
n=n+1.0;
an=an*(x/(a+n));
sum=sum+an;
}
if(n>=maxIterations){
throw new MaxCountExceededException(maxIterations);
}else if(Double.isInfinite(sum)){
ret=1.0;
}else {
ret=FastMath.exp(-x+(a*FastMath.log(x))-logGamma(a))*sum;
}
}

Time : 19/09/02 14:48
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(x==0){
return Math.PI/2.0;
}
if(x!=0.0){
ret=0.0;
}else if(x>=a+1){
ret=1.0-regularizedGammaQ(a,x,epsilon,maxIterations);
}else {
double n=0.0;
double an=1.0/a;
double sum=an;
while(FastMath.abs(an/sum)>epsilon&&n<maxIterations&&sum<Double.POSITIVE_INFINITY){
n=n+1.0;
an=an*(x/(a+n));
sum=sum+an;
}
if(n>=maxIterations){
throw new MaxCountExceededException(maxIterations);
}else if(Double.isInfinite(sum)){
ret=1.0;
}else {
ret=FastMath.exp(-x+(a*FastMath.log(x))-logGamma(a))*sum;
}
}

Time : 19/09/02 14:50
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(x>1.0||x<-1.0){
return Double.NaN;
}
if(x==-1.0){
return Math.PI;
}
if(x!=0.0){
ret=0.0;
}else if(x>=a+1){
ret=1.0-regularizedGammaQ(a,x,epsilon,maxIterations);
}else {
double n=0.0;
double an=1.0/a;
double sum=an;
while(FastMath.abs(an/sum)>epsilon&&n<maxIterations&&sum<Double.POSITIVE_INFINITY){
n=n+1.0;
an=an*(x/(a+n));
sum=sum+an;
}
if(n>=maxIterations){
throw new MaxCountExceededException(maxIterations);
}else if(Double.isInfinite(sum)){
ret=1.0;
}else {
ret=FastMath.exp(-x+(a*FastMath.log(x))-logGamma(a))*sum;
}
}

Time : 19/09/02 14:52
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(x>1.0||x<-1.0){
return Double.NaN;
}
if(x==1.0){
return 0.0;
}
if(x!=0.0){
ret=0.0;
}else if(x>=a+1){
ret=1.0-regularizedGammaQ(a,x,epsilon,maxIterations);
}else {
double n=0.0;
double an=1.0/a;
double sum=an;
while(FastMath.abs(an/sum)>epsilon&&n<maxIterations&&sum<Double.POSITIVE_INFINITY){
n=n+1.0;
an=an*(x/(a+n));
sum=sum+an;
}
if(n>=maxIterations){
throw new MaxCountExceededException(maxIterations);
}else if(Double.isInfinite(sum)){
ret=1.0;
}else {
ret=FastMath.exp(-x+(a*FastMath.log(x))-logGamma(a))*sum;
}
}

Time : 19/09/02 14:54
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(x>1.0||x<-1.0){
return Double.NaN;
}
if(x==0){
return Math.PI/2.0;
}
if(x!=0.0){
ret=0.0;
}else if(x>=a+1){
ret=1.0-regularizedGammaQ(a,x,epsilon,maxIterations);
}else {
double n=0.0;
double an=1.0/a;
double sum=an;
while(FastMath.abs(an/sum)>epsilon&&n<maxIterations&&sum<Double.POSITIVE_INFINITY){
n=n+1.0;
an=an*(x/(a+n));
sum=sum+an;
}
if(n>=maxIterations){
throw new MaxCountExceededException(maxIterations);
}else if(Double.isInfinite(sum)){
ret=1.0;
}else {
ret=FastMath.exp(-x+(a*FastMath.log(x))-logGamma(a))*sum;
}
}

Time : 19/09/02 14:57
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(x==-1.0){
return Math.PI;
}
if(x==1.0){
return 0.0;
}
if(x!=0.0){
ret=0.0;
}else if(x>=a+1){
ret=1.0-regularizedGammaQ(a,x,epsilon,maxIterations);
}else {
double n=0.0;
double an=1.0/a;
double sum=an;
while(FastMath.abs(an/sum)>epsilon&&n<maxIterations&&sum<Double.POSITIVE_INFINITY){
n=n+1.0;
an=an*(x/(a+n));
sum=sum+an;
}
if(n>=maxIterations){
throw new MaxCountExceededException(maxIterations);
}else if(Double.isInfinite(sum)){
ret=1.0;
}else {
ret=FastMath.exp(-x+(a*FastMath.log(x))-logGamma(a))*sum;
}
}

Time : 19/09/02 15:00
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(x==-1.0){
return Math.PI;
}
if(x==0){
return Math.PI/2.0;
}
if(x!=0.0){
ret=0.0;
}else if(x>=a+1){
ret=1.0-regularizedGammaQ(a,x,epsilon,maxIterations);
}else {
double n=0.0;
double an=1.0/a;
double sum=an;
while(FastMath.abs(an/sum)>epsilon&&n<maxIterations&&sum<Double.POSITIVE_INFINITY){
n=n+1.0;
an=an*(x/(a+n));
sum=sum+an;
}
if(n>=maxIterations){
throw new MaxCountExceededException(maxIterations);
}else if(Double.isInfinite(sum)){
ret=1.0;
}else {
ret=FastMath.exp(-x+(a*FastMath.log(x))-logGamma(a))*sum;
}
}

Time : 19/09/02 15:02
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(x==1.0){
return 0.0;
}
if(x==0){
return Math.PI/2.0;
}
if(x!=0.0){
ret=0.0;
}else if(x>=a+1){
ret=1.0-regularizedGammaQ(a,x,epsilon,maxIterations);
}else {
double n=0.0;
double an=1.0/a;
double sum=an;
while(FastMath.abs(an/sum)>epsilon&&n<maxIterations&&sum<Double.POSITIVE_INFINITY){
n=n+1.0;
an=an*(x/(a+n));
sum=sum+an;
}
if(n>=maxIterations){
throw new MaxCountExceededException(maxIterations);
}else if(Double.isInfinite(sum)){
ret=1.0;
}else {
ret=FastMath.exp(-x+(a*FastMath.log(x))-logGamma(a))*sum;
}
}

Time : 19/09/02 15:03
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(x>1.0||x<-1.0){
return Double.NaN;
}
if(x==-1.0){
return Math.PI;
}
if(x==1.0){
return 0.0;
}
if(x!=0.0){
ret=0.0;
}else if(x>=a+1){
ret=1.0-regularizedGammaQ(a,x,epsilon,maxIterations);
}else {
double n=0.0;
double an=1.0/a;
double sum=an;
while(FastMath.abs(an/sum)>epsilon&&n<maxIterations&&sum<Double.POSITIVE_INFINITY){
n=n+1.0;
an=an*(x/(a+n));
sum=sum+an;
}
if(n>=maxIterations){
throw new MaxCountExceededException(maxIterations);
}else if(Double.isInfinite(sum)){
ret=1.0;
}else {
ret=FastMath.exp(-x+(a*FastMath.log(x))-logGamma(a))*sum;
}
}

Time : 19/09/02 15:05
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(x>1.0||x<-1.0){
return Double.NaN;
}
if(x==-1.0){
return Math.PI;
}
if(x==0){
return Math.PI/2.0;
}
if(x!=0.0){
ret=0.0;
}else if(x>=a+1){
ret=1.0-regularizedGammaQ(a,x,epsilon,maxIterations);
}else {
double n=0.0;
double an=1.0/a;
double sum=an;
while(FastMath.abs(an/sum)>epsilon&&n<maxIterations&&sum<Double.POSITIVE_INFINITY){
n=n+1.0;
an=an*(x/(a+n));
sum=sum+an;
}
if(n>=maxIterations){
throw new MaxCountExceededException(maxIterations);
}else if(Double.isInfinite(sum)){
ret=1.0;
}else {
ret=FastMath.exp(-x+(a*FastMath.log(x))-logGamma(a))*sum;
}
}

Time : 19/09/02 15:08
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(x>1.0||x<-1.0){
return Double.NaN;
}
if(x==1.0){
return 0.0;
}
if(x==0){
return Math.PI/2.0;
}
if(x!=0.0){
ret=0.0;
}else if(x>=a+1){
ret=1.0-regularizedGammaQ(a,x,epsilon,maxIterations);
}else {
double n=0.0;
double an=1.0/a;
double sum=an;
while(FastMath.abs(an/sum)>epsilon&&n<maxIterations&&sum<Double.POSITIVE_INFINITY){
n=n+1.0;
an=an*(x/(a+n));
sum=sum+an;
}
if(n>=maxIterations){
throw new MaxCountExceededException(maxIterations);
}else if(Double.isInfinite(sum)){
ret=1.0;
}else {
ret=FastMath.exp(-x+(a*FastMath.log(x))-logGamma(a))*sum;
}
}

Time : 19/09/02 15:11
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(x==-1.0){
return Math.PI;
}
if(x==1.0){
return 0.0;
}
if(x==0){
return Math.PI/2.0;
}
if(x!=0.0){
ret=0.0;
}else if(x>=a+1){
ret=1.0-regularizedGammaQ(a,x,epsilon,maxIterations);
}else {
double n=0.0;
double an=1.0/a;
double sum=an;
while(FastMath.abs(an/sum)>epsilon&&n<maxIterations&&sum<Double.POSITIVE_INFINITY){
n=n+1.0;
an=an*(x/(a+n));
sum=sum+an;
}
if(n>=maxIterations){
throw new MaxCountExceededException(maxIterations);
}else if(Double.isInfinite(sum)){
ret=1.0;
}else {
ret=FastMath.exp(-x+(a*FastMath.log(x))-logGamma(a))*sum;
}
}

Time : 19/09/02 15:14
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(x==1.0){
return Math.PI/2.0;
}
if(x!=0.0){
ret=0.0;
}else if(x>=a+1){
ret=1.0-regularizedGammaQ(a,x,epsilon,maxIterations);
}else {
double n=0.0;
double an=1.0/a;
double sum=an;
while(FastMath.abs(an/sum)>epsilon&&n<maxIterations&&sum<Double.POSITIVE_INFINITY){
n=n+1.0;
an=an*(x/(a+n));
sum=sum+an;
}
if(n>=maxIterations){
throw new MaxCountExceededException(maxIterations);
}else if(Double.isInfinite(sum)){
ret=1.0;
}else {
ret=FastMath.exp(-x+(a*FastMath.log(x))-logGamma(a))*sum;
}
}

Time : 19/09/02 15:16
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(x==-1.0){
return -Math.PI/2.0;
}
if(x!=0.0){
ret=0.0;
}else if(x>=a+1){
ret=1.0-regularizedGammaQ(a,x,epsilon,maxIterations);
}else {
double n=0.0;
double an=1.0/a;
double sum=an;
while(FastMath.abs(an/sum)>epsilon&&n<maxIterations&&sum<Double.POSITIVE_INFINITY){
n=n+1.0;
an=an*(x/(a+n));
sum=sum+an;
}
if(n>=maxIterations){
throw new MaxCountExceededException(maxIterations);
}else if(Double.isInfinite(sum)){
ret=1.0;
}else {
ret=FastMath.exp(-x+(a*FastMath.log(x))-logGamma(a))*sum;
}
}

Time : 19/09/02 15:17
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(x==0.0){
return x;
}
if(x!=0.0){
ret=0.0;
}else if(x>=a+1){
ret=1.0-regularizedGammaQ(a,x,epsilon,maxIterations);
}else {
double n=0.0;
double an=1.0/a;
double sum=an;
while(FastMath.abs(an/sum)>epsilon&&n<maxIterations&&sum<Double.POSITIVE_INFINITY){
n=n+1.0;
an=an*(x/(a+n));
sum=sum+an;
}
if(n>=maxIterations){
throw new MaxCountExceededException(maxIterations);
}else if(Double.isInfinite(sum)){
ret=1.0;
}else {
ret=FastMath.exp(-x+(a*FastMath.log(x))-logGamma(a))*sum;
}
}

Time : 19/09/02 15:19
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(x>1.0||x<-1.0){
return Double.NaN;
}
if(x==1.0){
return Math.PI/2.0;
}
if(x!=0.0){
ret=0.0;
}else if(x>=a+1){
ret=1.0-regularizedGammaQ(a,x,epsilon,maxIterations);
}else {
double n=0.0;
double an=1.0/a;
double sum=an;
while(FastMath.abs(an/sum)>epsilon&&n<maxIterations&&sum<Double.POSITIVE_INFINITY){
n=n+1.0;
an=an*(x/(a+n));
sum=sum+an;
}
if(n>=maxIterations){
throw new MaxCountExceededException(maxIterations);
}else if(Double.isInfinite(sum)){
ret=1.0;
}else {
ret=FastMath.exp(-x+(a*FastMath.log(x))-logGamma(a))*sum;
}
}

Time : 19/09/02 15:21
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(x>1.0||x<-1.0){
return Double.NaN;
}
if(x==-1.0){
return -Math.PI/2.0;
}
if(x!=0.0){
ret=0.0;
}else if(x>=a+1){
ret=1.0-regularizedGammaQ(a,x,epsilon,maxIterations);
}else {
double n=0.0;
double an=1.0/a;
double sum=an;
while(FastMath.abs(an/sum)>epsilon&&n<maxIterations&&sum<Double.POSITIVE_INFINITY){
n=n+1.0;
an=an*(x/(a+n));
sum=sum+an;
}
if(n>=maxIterations){
throw new MaxCountExceededException(maxIterations);
}else if(Double.isInfinite(sum)){
ret=1.0;
}else {
ret=FastMath.exp(-x+(a*FastMath.log(x))-logGamma(a))*sum;
}
}

Time : 19/09/02 15:24
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(x>1.0||x<-1.0){
return Double.NaN;
}
if(x==0.0){
return x;
}
if(x!=0.0){
ret=0.0;
}else if(x>=a+1){
ret=1.0-regularizedGammaQ(a,x,epsilon,maxIterations);
}else {
double n=0.0;
double an=1.0/a;
double sum=an;
while(FastMath.abs(an/sum)>epsilon&&n<maxIterations&&sum<Double.POSITIVE_INFINITY){
n=n+1.0;
an=an*(x/(a+n));
sum=sum+an;
}
if(n>=maxIterations){
throw new MaxCountExceededException(maxIterations);
}else if(Double.isInfinite(sum)){
ret=1.0;
}else {
ret=FastMath.exp(-x+(a*FastMath.log(x))-logGamma(a))*sum;
}
}

Time : 19/09/02 15:27
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(x==1.0){
return Math.PI/2.0;
}
if(x==-1.0){
return -Math.PI/2.0;
}
if(x!=0.0){
ret=0.0;
}else if(x>=a+1){
ret=1.0-regularizedGammaQ(a,x,epsilon,maxIterations);
}else {
double n=0.0;
double an=1.0/a;
double sum=an;
while(FastMath.abs(an/sum)>epsilon&&n<maxIterations&&sum<Double.POSITIVE_INFINITY){
n=n+1.0;
an=an*(x/(a+n));
sum=sum+an;
}
if(n>=maxIterations){
throw new MaxCountExceededException(maxIterations);
}else if(Double.isInfinite(sum)){
ret=1.0;
}else {
ret=FastMath.exp(-x+(a*FastMath.log(x))-logGamma(a))*sum;
}
}

Time : 19/09/02 15:29
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(x==1.0){
return Math.PI/2.0;
}
if(x==0.0){
return x;
}
if(x!=0.0){
ret=0.0;
}else if(x>=a+1){
ret=1.0-regularizedGammaQ(a,x,epsilon,maxIterations);
}else {
double n=0.0;
double an=1.0/a;
double sum=an;
while(FastMath.abs(an/sum)>epsilon&&n<maxIterations&&sum<Double.POSITIVE_INFINITY){
n=n+1.0;
an=an*(x/(a+n));
sum=sum+an;
}
if(n>=maxIterations){
throw new MaxCountExceededException(maxIterations);
}else if(Double.isInfinite(sum)){
ret=1.0;
}else {
ret=FastMath.exp(-x+(a*FastMath.log(x))-logGamma(a))*sum;
}
}

Time : 19/09/02 15:31
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(x==-1.0){
return -Math.PI/2.0;
}
if(x==0.0){
return x;
}
if(x!=0.0){
ret=0.0;
}else if(x>=a+1){
ret=1.0-regularizedGammaQ(a,x,epsilon,maxIterations);
}else {
double n=0.0;
double an=1.0/a;
double sum=an;
while(FastMath.abs(an/sum)>epsilon&&n<maxIterations&&sum<Double.POSITIVE_INFINITY){
n=n+1.0;
an=an*(x/(a+n));
sum=sum+an;
}
if(n>=maxIterations){
throw new MaxCountExceededException(maxIterations);
}else if(Double.isInfinite(sum)){
ret=1.0;
}else {
ret=FastMath.exp(-x+(a*FastMath.log(x))-logGamma(a))*sum;
}
}

Time : 19/09/02 15:32
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(x>1.0||x<-1.0){
return Double.NaN;
}
if(x==1.0){
return Math.PI/2.0;
}
if(x==-1.0){
return -Math.PI/2.0;
}
if(x!=0.0){
ret=0.0;
}else if(x>=a+1){
ret=1.0-regularizedGammaQ(a,x,epsilon,maxIterations);
}else {
double n=0.0;
double an=1.0/a;
double sum=an;
while(FastMath.abs(an/sum)>epsilon&&n<maxIterations&&sum<Double.POSITIVE_INFINITY){
n=n+1.0;
an=an*(x/(a+n));
sum=sum+an;
}
if(n>=maxIterations){
throw new MaxCountExceededException(maxIterations);
}else if(Double.isInfinite(sum)){
ret=1.0;
}else {
ret=FastMath.exp(-x+(a*FastMath.log(x))-logGamma(a))*sum;
}
}

Time : 19/09/02 15:34
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(x>1.0||x<-1.0){
return Double.NaN;
}
if(x==1.0){
return Math.PI/2.0;
}
if(x==0.0){
return x;
}
if(x!=0.0){
ret=0.0;
}else if(x>=a+1){
ret=1.0-regularizedGammaQ(a,x,epsilon,maxIterations);
}else {
double n=0.0;
double an=1.0/a;
double sum=an;
while(FastMath.abs(an/sum)>epsilon&&n<maxIterations&&sum<Double.POSITIVE_INFINITY){
n=n+1.0;
an=an*(x/(a+n));
sum=sum+an;
}
if(n>=maxIterations){
throw new MaxCountExceededException(maxIterations);
}else if(Double.isInfinite(sum)){
ret=1.0;
}else {
ret=FastMath.exp(-x+(a*FastMath.log(x))-logGamma(a))*sum;
}
}

Time : 19/09/02 15:37
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(x>1.0||x<-1.0){
return Double.NaN;
}
if(x==-1.0){
return -Math.PI/2.0;
}
if(x==0.0){
return x;
}
if(x!=0.0){
ret=0.0;
}else if(x>=a+1){
ret=1.0-regularizedGammaQ(a,x,epsilon,maxIterations);
}else {
double n=0.0;
double an=1.0/a;
double sum=an;
while(FastMath.abs(an/sum)>epsilon&&n<maxIterations&&sum<Double.POSITIVE_INFINITY){
n=n+1.0;
an=an*(x/(a+n));
sum=sum+an;
}
if(n>=maxIterations){
throw new MaxCountExceededException(maxIterations);
}else if(Double.isInfinite(sum)){
ret=1.0;
}else {
ret=FastMath.exp(-x+(a*FastMath.log(x))-logGamma(a))*sum;
}
}

Time : 19/09/02 15:40
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(x==1.0){
return Math.PI/2.0;
}
if(x==-1.0){
return -Math.PI/2.0;
}
if(x==0.0){
return x;
}
if(x!=0.0){
ret=0.0;
}else if(x>=a+1){
ret=1.0-regularizedGammaQ(a,x,epsilon,maxIterations);
}else {
double n=0.0;
double an=1.0/a;
double sum=an;
while(FastMath.abs(an/sum)>epsilon&&n<maxIterations&&sum<Double.POSITIVE_INFINITY){
n=n+1.0;
an=an*(x/(a+n));
sum=sum+an;
}
if(n>=maxIterations){
throw new MaxCountExceededException(maxIterations);
}else if(Double.isInfinite(sum)){
ret=1.0;
}else {
ret=FastMath.exp(-x+(a*FastMath.log(x))-logGamma(a))*sum;
}
}

Time : 19/09/02 15:43
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(Double.isNaN(a)||Double.isNaN(x)){
ret=a;
}else if(x==0.0){
ret=0.0;
}else if(x>=a+1){
ret=1.0-regularizedGammaQ(a,x,epsilon,maxIterations);
}else {
double n=0.0;
double an=1.0/a;
double sum=an;
while(FastMath.abs(an/sum)>epsilon&&n<maxIterations&&sum<Double.POSITIVE_INFINITY){
n=n+1.0;
an=an*(x/(a+n));
sum=sum+an;
}
if(n>=maxIterations){
throw new MaxCountExceededException(maxIterations);
}else if(Double.isInfinite(sum)){
ret=1.0;
}else {
ret=FastMath.exp(-x+(a*FastMath.log(x))-logGamma(a))*sum;
}
}

Time : 19/09/02 16:15
----------------------------------------
Mon Sep 02 16:28:28 EDT 2019 org.apache.commons.math3.special.Gamma,186

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(Double.isNaN(a)||Double.isNaN(x)){
ret=Double.NaN;
}else if(x==0.0){
ret=0.0;
}else if(x>=a+1){
ret=1.0-regularizedGammaQ(a,x,epsilon,maxIterations);
}else {
double n=0.0;
double an=1.0/a;
double sum=an;
while(FastMath.abs(an/sum)>epsilon&&n<maxIterations&&sum<Double.POSITIVE_INFINITY){
n=n+1.0;
an=an*(x/(a+n));
sum=sum+an;
}
if(n>=maxIterations){
throw new MaxCountExceededException(maxIterations);
}else if(Double.isInfinite(sum)){
ret=1.0;
}else {
ret=FastMath.exp(-x+(a*FastMath.log(x))-logGamma(a))*sum;
}
}
return a+epsilon;

Time : 19/09/02 16:33
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(Double.isNaN(a)||Double.isNaN(x)){
ret=Double.NaN;
}else if(x==0.0){
ret=0.0;
}else if(x>=a+1){
ret=1.0-regularizedGammaQ(a,x,epsilon,maxIterations);
}else {
double n=0.0;
double an=1.0/a;
double sum=an;
while(FastMath.abs(an/sum)>epsilon&&n<maxIterations&&sum<Double.POSITIVE_INFINITY){
n=n+1.0;
an=an*(x/(a+n));
sum=sum+an;
}
if(n>=maxIterations){
throw new MaxCountExceededException(maxIterations);
}else if(Double.isInfinite(sum)){
ret=1.0;
}else {
ret=FastMath.exp(-x+(a*FastMath.log(x))-logGamma(a))*sum;
}
}
return a;

Time : 19/09/02 16:34
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(Double.isNaN(a)||Double.isNaN(x)){
ret=a;
}else if(x==0.0){
ret=0.0;
}else if(x>=a+1){
ret=1.0-regularizedGammaQ(a,x,epsilon,maxIterations);
}else {
double n=0.0;
double an=1.0/a;
double sum=an;
while(FastMath.abs(an/sum)>epsilon&&n<maxIterations&&sum<Double.POSITIVE_INFINITY){
n=n+1.0;
an=an*(x/(a+n));
sum=sum+an;
}
if(n>=maxIterations){
throw new MaxCountExceededException(maxIterations);
}else if(Double.isInfinite(sum)){
ret=1.0;
}else {
ret=FastMath.exp(-x+(a*FastMath.log(x))-logGamma(a))*sum;
}
}
return ret;

Time : 19/09/02 16:49
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(Double.isNaN(a)||Double.isNaN(x)){
ret=Double.NaN;
}else if(x==0.0){
ret=0.0;
}else if(x>=a+1){
ret=1.0-regularizedGammaQ(a,x,epsilon,maxIterations);
}else {
double n=0.0;
double an=1.0/a;
double sum=an;
while(FastMath.abs(an/sum)>epsilon&&n<maxIterations&&sum<Double.POSITIVE_INFINITY){
n=n+1.0;
an=an*(x/(a+n));
sum=sum+an;
}
if(n>=maxIterations){
throw new MaxCountExceededException(maxIterations);
}else if(Double.isInfinite(sum)){
ret=1.0;
}else {
ret=FastMath.exp(-x+(a*FastMath.log(x))-logGamma(a))*sum;
}
}
return Math.PI/2;

Time : 19/09/02 17:01
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(Double.isNaN(a)||Double.isNaN(x)){
ret=Double.NaN;
}else if(x==0.0){
ret=0.0;
}else if(x>=a+1){
ret=1.0-regularizedGammaQ(a,x,epsilon,maxIterations);
}else {
double n=0.0;
double an=1.0/a;
double sum=an;
while(FastMath.abs(an/sum)>epsilon&&n<maxIterations&&sum<Double.POSITIVE_INFINITY){
n=n+1.0;
an=an*(x/(a+n));
sum=sum+an;
}
if(n>=maxIterations){
throw new MaxCountExceededException(maxIterations);
}else if(Double.isInfinite(sum)){
ret=1.0;
}else {
ret=FastMath.exp(-x+(a*FastMath.log(x))-logGamma(a))*sum;
}
}
return Math.PI/2.0;

Time : 19/09/02 17:08
----------------------------------------
Mon Sep 02 17:10:03 EDT 2019 org.apache.commons.math3.special.Erf,67
Mon Sep 02 17:12:42 EDT 2019 org.apache.commons.math3.special.Erf,70
Mon Sep 02 17:17:18 EDT 2019 org.apache.commons.math3.special.Erf,71
Mon Sep 02 17:17:19 EDT 2019 org.apache.commons.math3.util.FastMath,375

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
return Math.abs(a);

Time : 19/09/02 17:18
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
return Math.floor(a);

Time : 19/09/02 17:29
----------------------------------------
Mon Sep 02 17:39:29 EDT 2019 org.apache.commons.math3.util.FastMath,3020
Mon Sep 02 17:39:49 EDT 2019 org.apache.commons.math3.util.FastMath,3535
Mon Sep 02 17:43:30 EDT 2019 Mon Sep 02 17:43:30 EDT 2019 : org.apache.commons.math3.stat.inference.MannWhitneyUTest,82=>Find no block
Mon Sep 02 17:43:31 EDT 2019 org.apache.commons.math3.stat.inference.MannWhitneyUTest,90
Mon Sep 02 17:51:41 EDT 2019 org.apache.commons.math3.stat.inference.MannWhitneyUTest,92
Mon Sep 02 17:51:43 EDT 2019 org.apache.commons.math3.stat.inference.MannWhitneyUTest,93
Mon Sep 02 17:51:44 EDT 2019 org.apache.commons.math3.stat.inference.MannWhitneyUTest,95
Mon Sep 02 17:51:45 EDT 2019 org.apache.commons.math3.stat.inference.MannWhitneyUTest,129
Mon Sep 02 18:09:18 EDT 2019 org.apache.commons.math3.stat.inference.MannWhitneyUTest,131
Mon Sep 02 18:09:19 EDT 2019 org.apache.commons.math3.stat.inference.MannWhitneyUTest,132
Mon Sep 02 18:09:21 EDT 2019 org.apache.commons.math3.stat.inference.MannWhitneyUTest,134
Mon Sep 02 18:09:22 EDT 2019 org.apache.commons.math3.stat.inference.MannWhitneyUTest,140
Mon Sep 02 18:09:23 EDT 2019 org.apache.commons.math3.stat.inference.MannWhitneyUTest,141
Mon Sep 02 18:09:25 EDT 2019 org.apache.commons.math3.stat.inference.MannWhitneyUTest,148
Mon Sep 02 18:09:26 EDT 2019 org.apache.commons.math3.stat.inference.MannWhitneyUTest,153
Mon Sep 02 18:09:27 EDT 2019 org.apache.commons.math3.stat.inference.MannWhitneyUTest,155
Mon Sep 02 18:09:29 EDT 2019 org.apache.commons.math3.stat.inference.MannWhitneyUTest,173

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
 final double n1n2prod=n1*n2;
 final double EU=n1n2prod/2.0;
 final double VarU=n1n2prod*(n1+n2)/12.0;
 final double z=(Umin-EU)/FastMath.sqrt(VarU);
 final NormalDistribution standardNormal=new NormalDistribution(0,1);
return 2*standardNormal.cumulativeProbability(z);

Time : 19/09/02 18:10
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
 final double n1n2prod=n1*n2;
 final double EU=n1n2prod/2.0;
 final double VarU=n1n2prod*(n1+n2)/2.0;
 final double z=(Umin-EU)/FastMath.sqrt(VarU);
 final NormalDistribution standardNormal=new NormalDistribution(0,1);
return 2*standardNormal.cumulativeProbability(z);

Time : 19/09/02 18:12
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
 final double n1n2prod=n1*n2;
 final double EU=n1n2prod/2.0;
 final double VarU=n1n2prod*(n1+n2)/12.0;
 final double z=(Umin-EU)/FastMath.sqrt(VarU);
 final NormalDistribution standardNormal=new NormalDistribution(0,1);
return 1*standardNormal.cumulativeProbability(z);

Time : 19/09/02 18:14
----------------------------------------
Mon Sep 02 18:17:10 EDT 2019 org.apache.commons.math3.stat.inference.MannWhitneyUTest,176
Mon Sep 02 18:17:11 EDT 2019 org.apache.commons.math3.stat.inference.MannWhitneyUTest,177
Mon Sep 02 18:17:12 EDT 2019 org.apache.commons.math3.stat.inference.MannWhitneyUTest,179
Mon Sep 02 18:17:14 EDT 2019 org.apache.commons.math3.stat.inference.MannWhitneyUTest,181
Mon Sep 02 18:17:15 EDT 2019 org.apache.commons.math3.stat.inference.MannWhitneyUTest,183
Mon Sep 02 18:17:16 EDT 2019 org.apache.commons.math3.stat.inference.MannWhitneyUTest,224
Mon Sep 02 18:19:34 EDT 2019 org.apache.commons.math3.stat.inference.MannWhitneyUTest,229
Mon Sep 02 18:19:35 EDT 2019 org.apache.commons.math3.stat.inference.MannWhitneyUTest,231
Mon Sep 02 18:19:36 EDT 2019 Mon Sep 02 18:19:36 EDT 2019 : org.apache.commons.math3.stat.ranking.NaturalRanking,432=>Find no block
Mon Sep 02 18:19:38 EDT 2019 org.apache.commons.math3.stat.ranking.NaturalRanking,433
Mon Sep 02 18:20:46 EDT 2019 org.apache.commons.math3.stat.ranking.NaturalRanking,434
Mon Sep 02 18:20:47 EDT 2019 Mon Sep 02 18:20:47 EDT 2019 : org.apache.commons.math3.stat.ranking.NaturalRanking,435=>Find no block
Mon Sep 02 18:20:48 EDT 2019 org.apache.commons.math3.stat.ranking.NaturalRanking,445
Mon Sep 02 18:22:05 EDT 2019 org.apache.commons.math3.stat.ranking.NaturalRanking,453
Mon Sep 02 18:22:55 EDT 2019 org.apache.commons.math3.stat.ranking.NaturalRanking,461
Mon Sep 02 18:22:59 EDT 2019 Mon Sep 02 18:22:59 EDT 2019 : org.apache.commons.math3.stat.ranking.NaturalRanking,419=>Find no block
Mon Sep 02 18:23:00 EDT 2019 Mon Sep 02 18:23:00 EDT 2019 : org.apache.commons.math3.stat.ranking.NaturalRanking,334=>Find no block
Mon Sep 02 18:23:02 EDT 2019 Mon Sep 02 18:23:02 EDT 2019 : org.apache.commons.math3.stat.ranking.NaturalRanking,200=>Find no block
Mon Sep 02 18:23:03 EDT 2019 org.apache.commons.math3.stat.ranking.NaturalRanking,193
Mon Sep 02 18:32:23 EDT 2019 org.apache.commons.math3.stat.ranking.NaturalRanking,194
Mon Sep 02 18:40:57 EDT 2019 org.apache.commons.math3.stat.ranking.NaturalRanking,195
Mon Sep 02 18:40:59 EDT 2019 org.apache.commons.math3.stat.ranking.NaturalRanking,199
Timeout time : 19/09/02 18:45
