=================================================
Project : math_68	start : 19/09/02 13:43
Current failed test : org.apache.commons.math.optimization.general.MinpackTest::testMinpackFreudensteinRoth | 19/09/02 13:43
Mon Sep 02 13:44:31 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,381
Mon Sep 02 13:45:41 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,607
Mon Sep 02 13:49:27 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,608
Mon Sep 02 13:49:28 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,510
Mon Sep 02 13:59:33 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,511
Mon Sep 02 13:59:33 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,512
Mon Sep 02 13:59:34 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,514
Mon Sep 02 14:10:12 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,515
Mon Sep 02 15:38:25 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,516
Mon Sep 02 15:38:26 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,517
Mon Sep 02 15:38:27 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,518
Mon Sep 02 15:38:28 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,519
Mon Sep 02 15:38:28 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,521
Mon Sep 02 15:38:29 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,522
Mon Sep 02 15:38:30 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,523
Mon Sep 02 15:38:31 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,525
Timeout time : 19/09/02 16:14
Current failed test : org.apache.commons.math.optimization.general.MinpackTest::testMinpackJennrichSampson | 19/09/02 16:14
Mon Sep 02 16:15:07 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,381

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
costRelativeTolerance=0;
if((0.1*cost>=previousCost)||(tmp<0.1)){
tmp=0.1;
}

Time : 19/09/02 16:16
----------------------------------------
Mon Sep 02 16:16:39 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,607

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(fp<0){
lmPar*=0.5;
paru=Math.min(paru,lmPar);
}

Time : 19/09/02 16:19
----------------------------------------
Mon Sep 02 16:20:52 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,608
Mon Sep 02 16:20:53 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,510

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=rank;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]*=diag[pj]/dxNorm;
}

Time : 19/09/02 16:21
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=rank;j<cols;++j){
int pj=permutation[j];
work1[pj]*=diag[pj]/dxNorm;
}

Time : 19/09/02 16:22
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=solvedCols;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]*=diag[pj]/dxNorm;
}

Time : 19/09/02 16:25
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]*=diag[j]/dxNorm;
}

Time : 19/09/02 16:27
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=rank;j<rank;++j){
int pj=permutation[j];
work1[pj]*=diag[pj]/dxNorm;
}

Time : 19/09/02 16:27
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
dxNorm*=orthoTolerance;
for(int j=rank;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]*=diag[pj]/dxNorm;
}

Time : 19/09/02 16:29
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols-rank;++j){
int pj=permutation[j];
work1[pj]*=diag[pj]/dxNorm;
}

Time : 19/09/02 16:30
----------------------------------------
Mon Sep 02 16:33:55 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,511
Mon Sep 02 16:33:56 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,512
Mon Sep 02 16:33:57 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,514

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=rank;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]*=diag[pj]/dxNorm;
}
sum2=0;

Time : 19/09/02 16:34
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=rank;j<cols;++j){
int pj=permutation[j];
work1[pj]*=diag[pj]/dxNorm;
}
sum2=0;

Time : 19/09/02 16:35
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=solvedCols;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]*=diag[pj]/dxNorm;
}
sum2=0;

Time : 19/09/02 16:36
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]*=diag[j]/dxNorm;
}
sum2=0;

Time : 19/09/02 16:39
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=rank;j<rank;++j){
int pj=permutation[j];
work1[pj]*=diag[pj]/dxNorm;
}
sum2=0;

Time : 19/09/02 16:40
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols-rank;++j){
int pj=permutation[j];
work1[pj]*=diag[pj]/dxNorm;
}
sum2=0;

Time : 19/09/02 16:42
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=solvedCols;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]*=diag[rank]/dxNorm;
}
sum2=0;

Time : 19/09/02 16:43
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<=solvedCols-rank;++j){
int pj=permutation[j];
work1[pj]*=diag[pj]/dxNorm;
}
sum2=0;

Time : 19/09/02 16:44
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]*=diag[pj]/dxNorm;
}
sum2=rank;

Time : 19/09/02 16:47
----------------------------------------
Mon Sep 02 16:48:38 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,515

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
sum++;
for(int i=0;i<j;++i){
sum+=jacobian[i][pj]*work1[permutation[i]];
}

Time : 19/09/02 16:50
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int i=0;i<j;++i){
sum+=jacobian[i][j]*work1[permutation[i]];
}

Time : 19/09/02 16:50
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int i=0;i<j;++i){
sum+=jacobian[i][i]*work1[permutation[i]];
}

Time : 19/09/02 16:51
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int i=pj;i<j;++i){
sum+=jacobian[i][pj]*work1[permutation[i]];
}

Time : 19/09/02 16:52
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int i=0;i<j;++i){
sum+=jacobian[i][permutation[pj]]*work1[permutation[i]];
}

Time : 19/09/02 16:53
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int i=pj;i<j;++i){
sum+=jacobian[i][permutation[pj]]*work1[permutation[i]];
}

Time : 19/09/02 16:53
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
sum=rank;
for(int i=0;i<j;++i){
sum+=jacobian[i][pj]*work1[permutation[i]];
}

Time : 19/09/02 16:59
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
sum*=orthoTolerance;
for(int i=pj;i<j;++i){
sum+=jacobian[i][pj]*work1[permutation[i]];
}

Time : 19/09/02 17:00
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
double sum=0;
for(int i=pj;i<j;++i){
sum+=jacobian[i][pj]*work1[permutation[i]];
}
double s=(work1[pj]-sum)/diagR[pj];
work1[pj]=s;
sum2+=s*s;
}

Time : 19/09/02 17:21
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
double sum=0;
for(int i=0;i<j;++i){
sum+=jacobian[i][j]*work1[permutation[i]];
}
double s=(work1[pj]-sum)/diagR[pj];
work1[pj]=s;
sum2+=s*s;
}

Time : 19/09/02 17:22
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
double sum=0;
for(int i=0;i<j;++i){
sum+=jacobian[i][i]*work1[permutation[i]];
}
double s=(work1[pj]-sum)/diagR[pj];
work1[pj]=s;
sum2+=s*s;
}

Time : 19/09/02 17:26
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
double sum=0;
for(int i=pj;i<j;++i){
sum+=jacobian[i][i]*work1[permutation[i]];
}
double s=(work1[pj]-sum)/diagR[pj];
work1[pj]=s;
sum2+=s*s;
}

Time : 19/09/02 17:26
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
double sum=solvedCols;
for(int i=0;i<j;++i){
sum+=jacobian[i][pj]*work1[permutation[i]];
}
double s=(work1[pj]-sum)/diagR[pj];
work1[pj]=s;
sum2+=s*s;
}

Time : 19/09/02 17:40
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
double sum=rank;
for(int i=0;i<j;++i){
sum+=jacobian[i][pj]*work1[permutation[i]];
}
double s=(work1[pj]-sum)/diagR[pj];
work1[pj]=s;
sum2+=s*s;
}

Time : 19/09/02 17:41
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
int sum=solvedCols;
for(int i=0;i<j;++i){
sum+=jacobian[i][pj]*work1[permutation[i]];
}
double s=(work1[pj]-sum)/diagR[pj];
work1[pj]=s;
sum2+=s*s;
}

Time : 19/09/02 17:42
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
int sum=rank;
for(int i=0;i<j;++i){
sum+=jacobian[i][pj]*work1[permutation[i]];
}
double s=(work1[pj]-sum)/diagR[pj];
work1[pj]=s;
sum2+=s*s;
}

Time : 19/09/02 17:42
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
double sum=0;
for(int i=0;i<j;++i){
sum+=jacobian[i][pj]*work1[permutation[i]];
}
double s=(work1[pj]-sum)/diagR[j];
work1[pj]=s;
sum2+=s*s;
}

Time : 19/09/02 17:49
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<rank;++j){
int pj=permutation[j];
double sum=0;
for(int i=0;i<j;++i){
sum+=jacobian[i][pj]*work1[permutation[i]];
}
double s=(work1[pj]-sum)/diagR[j];
work1[pj]=s;
sum2+=s*s;
}

Time : 19/09/02 17:50
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
double sum=pj;
for(int i=0;i<j;++i){
sum+=jacobian[i][i]*work1[permutation[i]];
}
double s=(work1[pj]-sum)/diagR[pj];
work1[pj]=s;
sum2+=s*s;
}

Time : 19/09/02 17:58
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
int sum=0;
for(int i=0;i<j;++i){
sum+=jacobian[i][i]*work1[permutation[i]];
}
double s=(work1[pj]-sum)/diagR[pj];
work1[pj]=s;
sum2+=s*s;
}

Time : 19/09/02 17:59
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
int sum=pj;
for(int i=0;i<j;++i){
sum+=jacobian[i][i]*work1[permutation[i]];
}
double s=(work1[pj]-sum)/diagR[pj];
work1[pj]=s;
sum2+=s*s;
}

Time : 19/09/02 18:06
----------------------------------------
Mon Sep 02 18:25:24 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,516
Mon Sep 02 18:25:24 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,517
Mon Sep 02 18:25:25 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,518
Mon Sep 02 18:25:26 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,519
Mon Sep 02 18:25:27 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,521
Mon Sep 02 18:25:28 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,522
Mon Sep 02 18:25:29 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,523
Mon Sep 02 18:25:30 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,525

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
double sum=0;
for(int i=0;i<j;++i){
sum+=jacobian[i][j]*work1[permutation[i]];
}
double s=(work1[pj]-sum)/diagR[pj];
work1[pj]=s;
sum2+=s*s;
}
parl=fp/(delta*sum2);

Time : 19/09/02 18:31
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
double sum=0;
for(int i=pj;i<j;++i){
sum+=jacobian[i][pj]*work1[permutation[i]];
}
double s=(work1[pj]-sum)/diagR[pj];
work1[pj]=s;
sum2+=s*s;
}
parl=fp/(delta*sum2);

Time : 19/09/02 18:33
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
double sum=0;
for(int i=0;i<j;++i){
sum+=jacobian[i][i]*work1[permutation[i]];
}
double s=(work1[pj]-sum)/diagR[pj];
work1[pj]=s;
sum2+=s*s;
}
parl=fp/(delta*sum2);

Time : 19/09/02 18:34
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
double sum=0;
for(int i=pj;i<j;++i){
sum+=jacobian[i][i]*work1[permutation[i]];
}
double s=(work1[pj]-sum)/diagR[pj];
work1[pj]=s;
sum2+=s*s;
}
parl=fp/(delta*sum2);

Time : 19/09/02 18:34
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
double sum=pj;
for(int i=pj;i<j;++i){
sum+=jacobian[i][pj]*work1[permutation[i]];
}
double s=(work1[pj]-sum)/diagR[pj];
work1[pj]=s;
sum2+=s*s;
}
parl=fp/(delta*sum2);

Time : 19/09/02 18:37
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
int sum=0;
for(int i=pj;i<j;++i){
sum+=jacobian[i][pj]*work1[permutation[i]];
}
double s=(work1[pj]-sum)/diagR[pj];
work1[pj]=s;
sum2+=s*s;
}
parl=fp/(delta*sum2);

Time : 19/09/02 18:38
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
int sum=pj;
for(int i=pj;i<j;++i){
sum+=jacobian[i][pj]*work1[permutation[i]];
}
double s=(work1[pj]-sum)/diagR[pj];
work1[pj]=s;
sum2+=s*s;
}
parl=fp/(delta*sum2);

Time : 19/09/02 18:39
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
double sum=rank;
for(int i=0;i<j;++i){
sum+=jacobian[i][pj]*work1[permutation[i]];
}
double s=(work1[pj]-sum)/diagR[pj];
work1[pj]=s;
sum2+=s*s;
}
parl=fp/(delta*sum2);

Time : 19/09/02 18:42
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
int sum=rank;
for(int i=0;i<j;++i){
sum+=jacobian[i][pj]*work1[permutation[i]];
}
double s=(work1[pj]-sum)/diagR[pj];
work1[pj]=s;
sum2+=s*s;
}
parl=fp/(delta*sum2);

Time : 19/09/02 18:42
----------------------------------------
Timeout time : 19/09/02 18:45
