=================================================
Project : math_64	start : 19/09/02 13:43
Current failed test : org.apache.commons.math.optimization.general.MinpackTest::testMinpackFreudensteinRoth | 19/09/02 13:43
Mon Sep 02 13:44:33 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,402
Mon Sep 02 13:45:43 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,627
Mon Sep 02 13:49:32 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,628
Mon Sep 02 13:49:33 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,605
Mon Sep 02 14:00:17 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,606
Mon Sep 02 14:00:18 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,607
Mon Sep 02 14:00:19 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,609
Mon Sep 02 14:44:34 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,610
Mon Sep 02 14:44:35 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,611
Mon Sep 02 14:44:36 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,612
Mon Sep 02 14:44:37 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,613
Mon Sep 02 14:44:38 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,614
Mon Sep 02 14:44:39 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,617

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
countdown=0;
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]/=work2[j];
double tmp=work1[pj];
for(int i=j+1;i<solvedCols;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}
}
sum2=0;
for(int j=0;j<solvedCols;++j){
double s=work1[permutation[j]];
sum2+=s*s;
}

Time : 19/09/02 15:13
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
countdown=0;
work1=work1.clone();
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]/=work2[j];
double tmp=work1[pj];
for(int i=j+1;i<solvedCols;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}
}
sum2=0;
for(int j=0;j<solvedCols;++j){
double s=work1[permutation[j]];
sum2+=s*s;
}

Time : 19/09/02 15:14
----------------------------------------
Mon Sep 02 15:14:44 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,618
Mon Sep 02 15:14:45 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,619
Mon Sep 02 15:14:46 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,620
Mon Sep 02 15:14:47 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,622
Mon Sep 02 15:29:48 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,625
Mon Sep 02 15:29:49 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,632
Mon Sep 02 15:34:19 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,530
Mon Sep 02 15:44:53 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,531
Mon Sep 02 15:44:54 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,532
Mon Sep 02 15:45:01 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,534
Mon Sep 02 15:57:47 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,535
Timeout time : 19/09/02 16:14
Current failed test : org.apache.commons.math.optimization.general.MinpackTest::testMinpackJennrichSampson | 19/09/02 16:14
Mon Sep 02 16:15:14 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,402

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
costRelativeTolerance=0;
if((0.1*cost>=previousCost)||(tmp<0.1)){
tmp=0.1;
}

Time : 19/09/02 16:16
----------------------------------------
Mon Sep 02 16:16:49 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,627

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
paru=sPar*Math.min(delta,10.0*gNorm);
lmPar/=sPar;
if(fp<0){
paru=Math.min(paru,lmPar);
}

Time : 19/09/02 16:18
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
paru=sPar*Math.min(delta,10.0*gNorm);
lmPar/=sPar;
if(cost<0){
paru=Math.min(paru,lmPar);
}

Time : 19/09/02 16:18
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(fp<0){
lmPar*=0.5;
paru=Math.min(paru,lmPar);
}

Time : 19/09/02 16:20
----------------------------------------
Mon Sep 02 16:22:00 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,628
Mon Sep 02 16:22:02 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,605

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]=work3[pj]*diag[j]/dxNorm;
}

Time : 19/09/02 16:27
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
dxNorm*=gNorm;
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]=work3[pj]*diag[pj]/dxNorm;
}

Time : 19/09/02 16:29
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
dxNorm*=gNorm;
for(int j=countdown;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]=work3[pj]*diag[pj]/dxNorm;
}

Time : 19/09/02 16:30
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols-countdown;++j){
int pj=permutation[j];
work1[pj]=work3[pj]*diag[pj]/dxNorm;
}

Time : 19/09/02 16:31
----------------------------------------
Mon Sep 02 16:34:39 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,606
Mon Sep 02 16:34:40 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,607
Mon Sep 02 16:34:41 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,609

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int i=j+1;i<j;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}

Time : 19/09/02 16:35
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int i=j+1;i<=j;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}

Time : 19/09/02 16:36
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
tmp++;
for(int i=j+1;i<solvedCols;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}

Time : 19/09/02 16:37
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
j++;
for(int i=j+1;i<solvedCols;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}

Time : 19/09/02 16:37
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
tmp++;
j++;
for(int i=j+1;i<solvedCols;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}

Time : 19/09/02 16:38
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int i=j+1;i<solvedCols;++i){
work1[permutation[i]]-=jacobian[i][i]*tmp;
}

Time : 19/09/02 16:41
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
tmp=Math.round(sPar);
for(int i=j+1;i<solvedCols;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}

Time : 19/09/02 16:44
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int i=j+1;i<permutation[pj];++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}

Time : 19/09/02 16:45
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int i=j+1;i<tmp-i;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}

Time : 19/09/02 16:50
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int i=j+1;i<solvedCols;++i){
work1[permutation[i]]-=jacobian[i][j]*tmp;
}

Time : 19/09/02 16:52
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
lmPar/=sPar;
for(int i=j+1;i<solvedCols;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}

Time : 19/09/02 16:53
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=solvedCols;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]/=work2[j];
double tmp=work1[pj];
for(int i=j+1;i<solvedCols;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}
}

Time : 19/09/02 16:54
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]/=work2[j];
double tmp=work1[pj];
for(int i=j+1;i<j;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}
}

Time : 19/09/02 16:55
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]/=work2[j];
double tmp=work1[pj];
for(int i=j+1;i<=j;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}
}

Time : 19/09/02 16:56
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=countdown;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]/=work2[j];
double tmp=work1[pj];
for(int i=j+1;i<solvedCols;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}
}

Time : 19/09/02 16:56
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]/=work2[j];
double tmp=work1[j];
for(int i=j+1;i<solvedCols;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}
}

Time : 19/09/02 17:01
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=rank;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]/=work2[j];
double tmp=work1[pj];
for(int i=j+1;i<solvedCols;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}
}

Time : 19/09/02 17:04
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=rank;j<cols;++j){
int pj=permutation[j];
work1[pj]/=work2[j];
double tmp=work1[pj];
for(int i=j+1;i<solvedCols;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}
}

Time : 19/09/02 17:04
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]/=work2[j];
double tmp=work1[pj];
for(int i=j+1;i<solvedCols;++i){
work1[permutation[i]]-=jacobian[i][j]*tmp;
}
}

Time : 19/09/02 17:05
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]/=work2[j];
double tmp=work1[pj];
for(int i=j+1;i<solvedCols-i;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}
}

Time : 19/09/02 17:10
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=solvedCols;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]/=work2[j];
double tmp=work1[j];
for(int i=j+1;i<solvedCols;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}
}

Time : 19/09/02 17:15
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=countdown;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]/=work2[j];
double tmp=work1[countdown];
for(int i=j+1;i<solvedCols;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}
}

Time : 19/09/02 17:16
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<cols;++j){
int pj=permutation[j];
work1[pj]/=work2[j];
double tmp=work1[j];
for(int i=j+1;i<solvedCols;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}
}

Time : 19/09/02 17:17
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<(solvedCols>>1);++j){
int pj=permutation[j];
work1[pj]/=work2[j];
double tmp=work1[pj];
for(int i=j+1;i<solvedCols;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}
}

Time : 19/09/02 17:27
----------------------------------------
Mon Sep 02 17:30:24 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,610
Mon Sep 02 17:30:25 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,611
Mon Sep 02 17:30:26 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,612
Mon Sep 02 17:30:27 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,613
Mon Sep 02 17:30:28 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,614
Mon Sep 02 17:30:29 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,617

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
++j;
double s=work1[permutation[j]];
sum2+=s*s;
}

Time : 19/09/02 17:31
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
work1[j]=0;
double s=work1[permutation[j]];
sum2+=s*s;
}

Time : 19/09/02 17:34
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
sum2=gNorm;
for(int j=0;j<solvedCols;++j){
double s=work1[permutation[j]];
sum2+=s*s;
}

Time : 19/09/02 17:40
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
gNorm=sPar;
sum2=gNorm;
for(int j=0;j<solvedCols;++j){
double s=work1[permutation[j]];
sum2+=s*s;
}

Time : 19/09/02 17:40
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]/=work2[j];
double tmp=work1[pj];
for(int i=j+1;i<j;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}
}
sum2=0;
for(int j=0;j<solvedCols;++j){
double s=work1[permutation[j]];
sum2+=s*s;
}

Time : 19/09/02 17:43
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]/=work2[j];
double tmp=work1[pj];
for(int i=j+1;i<=j;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}
}
sum2=0;
for(int j=0;j<solvedCols;++j){
double s=work1[permutation[j]];
sum2+=s*s;
}

Time : 19/09/02 17:43
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=countdown;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]/=work2[j];
double tmp=work1[pj];
for(int i=j+1;i<solvedCols;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}
}
sum2=0;
for(int j=0;j<solvedCols;++j){
double s=work1[permutation[j]];
sum2+=s*s;
}

Time : 19/09/02 17:44
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=rank;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]/=work2[j];
double tmp=work1[pj];
for(int i=j+1;i<solvedCols;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}
}
sum2=0;
for(int j=0;j<solvedCols;++j){
double s=work1[permutation[j]];
sum2+=s*s;
}

Time : 19/09/02 17:45
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]/=work2[j];
double tmp=work1[pj];
for(int i=j+1;i<solvedCols;++i){
work1[permutation[i]]-=jacobian[i][j]*tmp;
}
}
sum2=0;
for(int j=0;j<solvedCols;++j){
double s=work1[permutation[j]];
sum2+=s*s;
}

Time : 19/09/02 17:47
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]/=work2[j];
double tmp=work1[j];
for(int i=j+1;i<solvedCols;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}
}
sum2=0;
for(int j=0;j<solvedCols;++j){
double s=work1[permutation[j]];
sum2+=s*s;
}

Time : 19/09/02 17:48
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=solvedCols;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]/=work2[j];
double tmp=work1[pj];
for(int i=j+1;i<solvedCols;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}
}
sum2=0;
for(int j=0;j<solvedCols;++j){
double s=work1[permutation[j]];
sum2+=s*s;
}

Time : 19/09/02 17:50
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=countdown;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]/=work2[j];
double tmp=work1[j];
for(int i=j+1;i<solvedCols;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}
}
sum2=0;
for(int j=0;j<solvedCols;++j){
double s=work1[permutation[j]];
sum2+=s*s;
}

Time : 19/09/02 17:51
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
j++;
int pj=permutation[j];
work1[pj]/=work2[j];
double tmp=work1[pj];
for(int i=j+1;i<solvedCols;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}
}
sum2=0;
for(int j=0;j<solvedCols;++j){
double s=work1[permutation[j]];
sum2+=s*s;
}

Time : 19/09/02 17:53
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]/=work2[j];
double tmp=work1[pj];
for(int i=j+1;i<solvedCols-countdown;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}
}
sum2=0;
for(int j=0;j<solvedCols;++j){
double s=work1[permutation[j]];
sum2+=s*s;
}

Time : 19/09/02 17:54
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=countdown;j<cols;++j){
int pj=permutation[j];
work1[pj]/=work2[j];
double tmp=work1[pj];
for(int i=j+1;i<solvedCols;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}
}
sum2=0;
for(int j=0;j<solvedCols;++j){
double s=work1[permutation[j]];
sum2+=s*s;
}

Time : 19/09/02 17:57
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=countdown;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]/=work2[j];
double tmp=work1[countdown];
for(int i=j+1;i<solvedCols;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}
}
sum2=0;
for(int j=0;j<solvedCols;++j){
double s=work1[permutation[j]];
sum2+=s*s;
}

Time : 19/09/02 17:57
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<cols;++j){
int pj=permutation[j];
work1[pj]/=work2[j];
double tmp=work1[j];
for(int i=j+1;i<solvedCols;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}
}
sum2=0;
for(int j=0;j<solvedCols;++j){
double s=work1[permutation[j]];
sum2+=s*s;
}

Time : 19/09/02 17:58
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]/=work2[j];
double tmp=work1[pj];
for(int i=j+1;i<solvedCols;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}
}
sum2=solvedCols;
for(int j=0;j<solvedCols;++j){
double s=work1[permutation[j]];
sum2+=s*s;
}

Time : 19/09/02 18:03
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=countdown;j<countdown;++j){
int pj=permutation[j];
work1[pj]/=work2[j];
double tmp=work1[pj];
for(int i=j+1;i<solvedCols;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}
}
sum2=0;
for(int j=0;j<solvedCols;++j){
double s=work1[permutation[j]];
sum2+=s*s;
}

Time : 19/09/02 18:04
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<(solvedCols>>1);++j){
int pj=permutation[j];
work1[pj]/=work2[j];
double tmp=work1[pj];
for(int i=j+1;i<solvedCols;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}
}
sum2=0;
for(int j=0;j<solvedCols;++j){
double s=work1[permutation[j]];
sum2+=s*s;
}

Time : 19/09/02 18:05
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
countdown=0;
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]/=work2[j];
double tmp=work1[pj];
for(int i=j+1;i<solvedCols;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}
}
sum2=0;
for(int j=0;j<solvedCols;++j){
double s=work1[permutation[j]];
sum2+=s*s;
}

Time : 19/09/02 18:07
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
countdown=0;
work1=work1.clone();
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]/=work2[j];
double tmp=work1[pj];
for(int i=j+1;i<solvedCols;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}
}
sum2=0;
for(int j=0;j<solvedCols;++j){
double s=work1[permutation[j]];
sum2+=s*s;
}

Time : 19/09/02 18:08
----------------------------------------
Mon Sep 02 18:09:21 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,618
Mon Sep 02 18:09:22 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,619
Mon Sep 02 18:09:22 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,620
Mon Sep 02 18:09:24 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,622

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
parl=lmPar;
if(fp>0){
parl=Math.max(parl,lmPar);
}else if(fp<0){
paru=Math.min(paru,lmPar);
}

Time : 19/09/02 18:10
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
parl=Math.sqrt(dxNorm);
if(fp>0){
parl=Math.max(parl,lmPar);
}else if(fp<0){
paru=Math.min(paru,lmPar);
}

Time : 19/09/02 18:10
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(delta>0){
parl=Math.max(parl,lmPar);
}else if(fp<0){
paru=Math.min(paru,lmPar);
}

Time : 19/09/02 18:11
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
parl=Math.sqrt(dxNorm);
if(delta>0){
parl=Math.max(parl,lmPar);
}else if(fp<0){
paru=Math.min(paru,lmPar);
}

Time : 19/09/02 18:12
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
paru=parl-fp;
if(delta>0){
parl=Math.max(parl,lmPar);
}else if(fp<0){
paru=Math.min(paru,lmPar);
}

Time : 19/09/02 18:12
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
parl=Math.sqrt(dxNorm);
paru=parl-fp;
if(fp>0){
parl=Math.max(parl,lmPar);
}else if(fp<0){
paru=Math.min(paru,lmPar);
}

Time : 19/09/02 18:13
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
parl=Math.sqrt(dxNorm);
paru=parl-fp;
if(delta>0){
parl=Math.max(parl,lmPar);
}else if(fp<0){
paru=Math.min(paru,lmPar);
}

Time : 19/09/02 18:13
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(lmPar>0){
parl=Math.max(parl,lmPar);
}else if(fp<0){
paru=Math.min(paru,lmPar);
}

Time : 19/09/02 18:14
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(fp>0){
lmPar*=0.5;
parl=Math.max(parl,lmPar);
}else if(fp<0){
paru=Math.min(paru,lmPar);
}

Time : 19/09/02 18:15
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(lmPar>0){
lmPar*=0.5;
parl=Math.max(parl,lmPar);
}else if(fp<0){
paru=Math.min(paru,lmPar);
}

Time : 19/09/02 18:15
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
double s=work1[permutation[j]];
sum2+=s*s;
}
double correction=dxNorm/(delta*sum2);
if(fp>0){
parl=Math.max(parl,lmPar);
}else if(fp<0){
paru=Math.min(paru,lmPar);
}

Time : 19/09/02 18:19
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(sum2<=0.1*delta){
parl=0;
return ;
}
for(int j=0;j<solvedCols;++j){
double s=work1[permutation[j]];
sum2+=s*s;
}
double correction=fp/(delta*sum2);
if(fp>0){
parl=Math.max(parl,lmPar);
}else if(fp<0){
paru=Math.min(paru,lmPar);
}

Time : 19/09/02 18:19
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
double s=work1[permutation[j]];
sum2+=s*s;
}
paru=Math.sqrt(dxNorm);
double correction=dxNorm/(delta*sum2);
if(fp>0){
parl=Math.max(parl,lmPar);
}else if(fp<0){
paru=Math.min(paru,lmPar);
}

Time : 19/09/02 18:20
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(sum2<=0.1*delta){
parl=0;
return ;
}
for(int j=0;j<solvedCols;++j){
double s=work1[permutation[j]];
sum2+=s*s;
}
double correction=dxNorm/(delta*sum2);
if(fp>0){
parl=Math.max(parl,lmPar);
}else if(fp<0){
paru=Math.min(paru,lmPar);
}

Time : 19/09/02 18:21
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(sum2<=0.1*delta){
parl=0;
return ;
}
for(int j=0;j<solvedCols;++j){
double s=work1[permutation[j]];
sum2+=s*s;
}
paru=Math.sqrt(dxNorm);
double correction=fp/(delta*sum2);
if(fp>0){
parl=Math.max(parl,lmPar);
}else if(fp<0){
paru=Math.min(paru,lmPar);
}

Time : 19/09/02 18:21
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(sum2<=0.1*delta){
parl=0;
return ;
}
for(int j=0;j<solvedCols;++j){
double s=work1[permutation[j]];
sum2+=s*s;
}
paru=Math.sqrt(dxNorm);
double correction=dxNorm/(delta*sum2);
if(fp>0){
parl=Math.max(parl,lmPar);
}else if(fp<0){
paru=Math.min(paru,lmPar);
}

Time : 19/09/02 18:22
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
double s=work1[permutation[j]];
sum2+=s*s;
}
double correction=fp/(delta*sum2);
if(delta>0){
parl=Math.max(parl,lmPar);
}else if(fp<0){
paru=Math.min(paru,lmPar);
}

Time : 19/09/02 18:23
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
double s=work1[permutation[j]];
sum2+=s*s;
}
double correction=fp/(delta*sum2);
parl=Math.sqrt(dxNorm);
if(fp>0){
parl=Math.max(parl,lmPar);
}else if(fp<0){
paru=Math.min(paru,lmPar);
}

Time : 19/09/02 18:23
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
double s=work1[permutation[j]];
sum2+=s*s;
}
double correction=fp/(delta*sum2);
parl=Math.sqrt(dxNorm);
if(delta>0){
parl=Math.max(parl,lmPar);
}else if(fp<0){
paru=Math.min(paru,lmPar);
}

Time : 19/09/02 18:24
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
double s=work1[permutation[j]];
sum2+=s*s;
}
double correction=fp/(delta*sum2);
paru=parl-fp;
if(delta>0){
parl=Math.max(parl,lmPar);
}else if(fp<0){
paru=Math.min(paru,lmPar);
}

Time : 19/09/02 18:25
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
double s=work1[permutation[j]];
sum2+=s*s;
}
double correction=fp/(delta*sum2);
parl=Math.sqrt(dxNorm);
paru=parl-fp;
if(fp>0){
parl=Math.max(parl,lmPar);
}else if(fp<0){
paru=Math.min(paru,lmPar);
}

Time : 19/09/02 18:25
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
double s=work1[permutation[j]];
sum2+=s*s;
}
double correction=fp/(delta*sum2);
parl=Math.sqrt(dxNorm);
paru=parl-fp;
if(delta>0){
parl=Math.max(parl,lmPar);
}else if(fp<0){
paru=Math.min(paru,lmPar);
}

Time : 19/09/02 18:26
----------------------------------------
Mon Sep 02 18:33:48 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,625
Mon Sep 02 18:33:48 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,632

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(fp>0){
parl=Math.max(parl,lmPar);
}else if(fp<0){
lmPar*=0.5;
paru=Math.min(paru,lmPar);
}
lmPar=Math.max(parl,lmPar+correction);

Time : 19/09/02 18:35
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
parl=Math.sqrt(dxNorm);
if(fp>0){
parl=Math.max(parl,lmPar);
}else if(fp<0){
paru=Math.min(paru,lmPar);
}
lmPar=Math.max(parl,lmPar+correction);

Time : 19/09/02 18:36
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(delta>0){
parl=Math.max(parl,lmPar);
}else if(fp<0){
paru=Math.min(paru,lmPar);
}
lmPar=Math.max(parl,lmPar+correction);

Time : 19/09/02 18:37
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
parl=paru-fp;
if(fp>0){
parl=Math.max(parl,lmPar);
}else if(fp<0){
paru=Math.min(paru,lmPar);
}
lmPar=Math.max(parl,lmPar+correction);

Time : 19/09/02 18:37
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
paru=Math.sqrt(dxNorm);
if(delta>0){
parl=Math.max(parl,lmPar);
}else if(fp<0){
paru=Math.min(paru,lmPar);
}
lmPar=Math.max(parl,lmPar+correction);

Time : 19/09/02 18:38
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
parl=paru-fp;
if(delta>0){
parl=Math.max(parl,lmPar);
}else if(fp<0){
paru=Math.min(paru,lmPar);
}
lmPar=Math.max(parl,lmPar+correction);

Time : 19/09/02 18:38
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(correction*fp>0.0){
parl=Math.max(parl,lmPar);
}else if(fp<0){
paru=Math.min(paru,lmPar);
}
lmPar=Math.max(parl,lmPar+correction);

Time : 19/09/02 18:39
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(correction*fp>0){
parl=Math.max(parl,lmPar);
}else if(fp<0){
paru=Math.min(paru,lmPar);
}
lmPar=Math.max(parl,lmPar+correction);

Time : 19/09/02 18:40
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(correction*fp>=0){
parl=Math.max(parl,lmPar);
}else if(fp<0){
paru=Math.min(paru,lmPar);
}
lmPar=Math.max(parl,lmPar+correction);

Time : 19/09/02 18:41
----------------------------------------
Mon Sep 02 18:42:09 EDT 2019 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,530

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=rank;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]*=diag[pj]/dxNorm;
}

Time : 19/09/02 18:43
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=rank;j<cols;++j){
int pj=permutation[j];
work1[pj]*=diag[pj]/dxNorm;
}

Time : 19/09/02 18:43
----------------------------------------
Timeout time : 19/09/02 18:45
